#+BEGIN_QUOTE
Que sais-je ?
#+END_QUOTE
#+title: The REAL 2e Asteroid CONFIG
#+author: 2e Asteroid (Dan.)

* Motivations
Before I start, I want to outline some key goals and rules that I should always keep in the back of my mind when I start configuring.
*Goals:*
 - Construct a functional and ergonomic (enough) /text/ editor that can support any text manipulations I need.
 - Create a clean, aesthetic, easy-on-the-eyes screen that makes me want to stay in Emacs longer, not run out of it.
 - Conjure Emacs fast and easy -- none of that waiting 20 minutes.
 - Have software reproducible from anywhere.

*Rules:*
 - When choosing between function and flow, choose a median between either.
 - Make text manipulation and entering keyboard-focused, none of that buttons and widgets.
 - However, using a mouse is fine.
 - Choose a median between simple and complex, something that starts off easy and can grow along with me.
 - Fuck bells

Thanks to all of the other Emacs configs that I stole a snippet or two of code from.
*Some Notable Configs:*
 - https://emacs.metaphoric.dev/
 - https://github.com/protesilaos/dotfiles
 - https://raw.githubusercontent.com/wiki/domtronn/all-the-icons.el/Mode%20Line.md
 -


* Constant Data
This just has stuff like name, email, operating system, and so on.
#+BEGIN_SRC emacs-lisp

  (defconst *2e/full-name* "Daniel Lin"
    "Stores your full name.")
  (defconst *2e/display-name* "Daniel L."
    "Stores your display name.")
  (defconst *2e/email* "two-e-asteroid@outlook.com"
    "Stores your main email address.")

#+END_SRC

#+RESULTS:
: *2e/email*


* Bootstrap
** "Sane" Defaults
What's sanity these days except for a human construct for the comprehensible?
#+BEGIN_SRC emacs-lisp

  (when (display-graphic-p)        ; When Emacs is running as a GUI (gooey???) application
    (blink-cursor-mode 0)          ; Stops the cursor from blinking; it's actually kind of annoying now that I think about it
    (scroll-bar-mode 0)            ; Removes the scroll bar at the right -- you don't /really/ need this
    (tool-bar-mode 0)              ; Removes the buttons, "fit a square into a circular hole" tool bar (Or is this the textual one?)
    (tooltip-mode 0))              ; Removes tool tips from appearing in popup windows
  (setq use-dialog-box nil         ; For dialog regarding stuff, don't use a popup window
        use-file-dialog nil)       ; Same thing as above, except for files, me thinks

#+END_SRC

#+RESULTS:

** "More Sane" Defaults
If sanity is the comprehensible, then let's make it more comprehensible!
#+BEGIN_SRC emacs-lisp

  (setq-default                             ; This sets variables, but for buffer-local vars, it sets it as the default.
   ad-redefinition-action 'accept           ; This makes it so that when you redefine an existing function, it accepts that, and won't warn you about it. Developer knows best..

   auto-window-vscroll nil                  ; This makes vertical scrolling better for terminals.

   confirm-kill-emacs 'y-or-n-p             ; Allows you to kill Emacs with just y and n. I don't think you need to be typing words out here.

   cursor-in-non-selected-windows nil       ; You're not editing in those windows, so you don't have to know where the cursor is.

   delete-by-moving-to-trash t              ; Takes deleted files to the trash, so you can quickly restore a file if needed.

   display-time-default-load-average nil    ; Removes the CPU load average after the time.

   display-time-format "%k:%M:%S (%Z)"      ; Displays the time as "24 Hours With Fill: Minutes : Seconds (Time Zone)"

   fill-column 80                           ; This controls when stuff like Auto-Fill-Mode will wrap.

   help-window-select t                     ; This gives the focused window spotlight to help windows when you open them

   indent-tabs-mode nil                     ; The classic Tabs v. Spaces argument. Shut the fuck up.

   inhibit-startup-screen t                 ; This removes the classic but sadly out-of-place starting screen.

   initial-scratch-message ""               ; Instead of some helpful statements, we don't give the scratch buffer a message

   mouse-yank-at-point t                    ; Making Emacs mouse yanking a bit better, je pense...

   ns-use-srgb-colorspace nil               ; Using Adobe RGB instead of standardRGB, since it has more colors

   select-enable-clipboard t                ; Mind-melding the system clipboard with the Emacs clipboard, to make stuff easier.

   sentence-end-double-space nil            ; Double SPACES ?!?

   show-help-function nil                   ; 'Tis for the tool bar, which we don't use

   show-trailing-whitespace t               ; Making trailing whitespace more visible

   split-height-threshold 80                ; Some window splitting stuff

   split-width-threshold 40                 ; Same thing here

   tab-width 4                              ; A 4 tab-width is standard

   uniquify-buffer-name-style 'forward      ; In case of the same file name, this'll show the different directories the files are in, with a "/".

   window-combination-resize t              ; Resizes the windows proportionally

   x-stretch-cursor nil                     ; Makes the cursor stretch to fit the glyph it's on, which looks kind of bad, actually

   delete-old-versions nil                  ; Storage is cheap, while ideas are ephemeral

   version-control t                        ; Version control is useful always

   ring-bell-function 'ignore               ; Shut up, PLEASE

   inhibit-compacting-font-caches t         ; Uses more memory, but speedier

   recentf-mode t                           ; Shows recent files

   make-backup-files t                      ; Ideas are ephemeral

   display-line-numbers-type 'relative      ; Just in case I use display-line-numbers (Never-ish)

   vc-follow-symlinks t                     ; Symlinks

   use-default-font-for-symbols nil         ; We don't want the same font for everything, unless we specify it.

   frame-inhibit-implied-resize nil         ; Symlink

   pop-up-windows nil)                      ; Just annoying

  (cd "~/")                                 ; Takes us to the home directory.

  (delete-selection-mode 1)                 ; Instead of just yanking to the buffer, we remove what we highlighted when we yank to text

  (display-time)                            ; What does this do? Only time will tell.

  (global-auto-revert-mode 1)               ; Changes on the disk means changes in Emacs

  (fringe-mode '(8 . 0))                    ; Leaves some space on the left for git / magit(?)

  (electric-pair-mode t)                    ; Automatically inserts closing parentheses, etc.

  (electric-indent-mode t)                  ; Automatically indents for you

  (defalias 'yes-or-no-p 'y-or-n-p)         ; More conciseness! Yummy

  (global-subword-mode 1)                   ; It can now iterate through camelCase words

  (menu-bar-mode 0)                         ; It's still kind of useful

  (mouse-avoidance-mode 'jump)              ; No more collisions

  (put 'downcase-region 'disabled nil)      ; Enables downcase-region

  (put 'upcase-region 'disabled nil)        ; Enables upcase-region

  (show-paren-mode 1)                       ; Really useful -- it highlights the matching parentheses, or makes it turn a warning color

  (add-hook 'calendar-mode-hook (lambda () (setq show-trailing-whitespace nil)))           ; Trailing whitespace makes it look weird

#+END_SRC

#+RESULTS:
| (lambda nil (setq show-trailing-whitespace nil)) | org--setup-calendar-bindings |

** Fullscreen?! Yippee
#+BEGIN_SRC emacs-lisp

  (if (string-equal window-system 'ns)
      (toggle-frame-maximized)
    (toggle-frame-fullscreen))

#+END_SRC

#+RESULTS:

** Focusing out of a Buffer will Garbage Collect
#+BEGIN_SRC emacs-lisp

  (add-hook 'focus-out-hook #'garbage-collect)

#+END_SRC

#+RESULTS:
| garbage-collect |

** Save Removes Trailing Whitespace
#+BEGIN_SRC emacs-lisp

  (add-hook 'before-save-hook 'delete-trailing-whitespace)

#+END_SRC

#+RESULTS:
| delete-trailing-whitespace |

** Default to UTF-8 Encoding
#+BEGIN_SRC emacs-lisp
  (set-default-coding-systems 'utf-8)
  (set-language-environment "UTF-8")
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

#+RESULTS:

** Stops Littering
#+BEGIN_SRC emacs-lisp

    (require 'no-littering)
    (setq no-littering-etc-directory
      (expand-file-name "config/" user-emacs-directory))               ; Puts all configuration files in a "config" folder.
    (setq no-littering-var-directory
      (expand-file-name "data/" user-emacs-directory))                 ; Puts all data files in a "data" folder.

  (setq user-emacs-directory "C:/Users/linyi/AppData/Roaming/.emacs.d/")

    (require 'recentf)
    (add-to-list 'recentf-exclude                                          ; Excludes all no-littering files from recentf
             (recentf-expand-file-name no-littering-var-directory))
    (add-to-list 'recentf-exclude                                          ; ^
             (recentf-expand-file-name no-littering-etc-directory))

    (setq custom-file (no-littering-expand-etc-file-name "custom.el"))     ; Stores Emacs' configuration interface in the config folder, called custom.el
#+END_SRC

#+RESULTS:
: c:/Users/linyi/AppData/Roaming/.emacs.d/config/custom.el

** The Garbage Collector Magic Hack 🎩 🪄
Pretty cool.
#+BEGIN_SRC emacs-lisp

  (require 'gcmh)
  (setq gcmh-low-cons-threshold 800000            ; This is the normal garbage-collection rate, when you're actively working
        gcmh-high-cons-threshold #x40000000       ; This is the idling garbage-collection rate
        gcmh-idle-delay 15                        ; How much time needs to pass to count as idle delay. Or, you can set it to auto.
        gcmh-auto-idle-delay-factor 20            ; A factor that calculates the idle delay time, if you set the idle delay to auto.
        )

#+END_SRC

#+RESULTS:
: 20

** General Utils
Some utility functions
#+BEGIN_SRC emacs-lisp

  (defun 2e/open-config-org-file ()                                      ; A function that opens up your configuration file
    (interactive)
    (find-file (expand-file-name "config.org" user-emacs-directory)))

  (defun 2e/add-function-to-multiple-hooks (func hooks)                  ; This adds the same function to multiple hooks
    (mapc (lambda (hook)
        (add-hook hook func))
      hooks))

  (defun 2e-emacs-remind (reminder parent)
  (with-output-to-temp-buffer "Reminder"
    (princ (format "%s\n" reminder))
    (princ (format-time-string "Sent at: %H:%M\n"))
    (princ (format "Sent by %s\n" parent)))
  (alert-toast-notify `(:title ,parent :message ,reminder :data (:alarm default :long t))))
#+END_SRC

#+RESULTS:
: 2e-emacs-remind

** Highlight Line
#+BEGIN_SRC emacs-lisp

  (add-hook 'prog-mode-hook 'hl-line-mode)  ; Makes the current line be highlighted

#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode | rainbow-mode | fira-code-mode | hl-line-mode |


* Fonts
** Set Fallback Fonts
This support both Windows and Linux, provided you have the fonts installed. MacOS might be able to be added, but I'm not sure how to differentiate between Linux and macOS.
Fonts that you have to download:
 - Windows
   - Unifont
     [[https://unifoundry.com/pub/unifont/unifont-15.1.04/font-builds/unifont-15.1.04.otf][Standard Unifont]]
     [[https://unifoundry.com/pub/unifont/unifont-15.1.04/font-builds/unifont_upper-15.1.04.otf][Unifont Upper]]
 - Linux
   - Noto Color Emoji
     [[https://github.com/googlefonts/noto-emoji/raw/main/fonts/NotoColorEmoji.ttf][Noto Color Emoji]]
   - Unifont
     [[https://unifoundry.com/pub/unifont/unifont-15.1.04/font-builds/unifont-15.1.04.otf][Standard Unifont]]
     [[https://unifoundry.com/pub/unifont/unifont-15.1.04/font-builds/unifont_upper-15.1.04.otf][Unifont Upper]]
#+BEGIN_SRC emacs-lisp

  (cond ((string-equal window-system 'w32) (progn
                                              (when (member "Segoe UI Emoji" (font-family-list))
                                                (set-fontset-font t 'symbol (font-spec :family "Segoe UI Emoji") nil 'prepend)
                                                (set-fontset-font "fontset-default" '(#xFE00 . #xFE0F) "Segoe UI Emoji"))

                                              (when (member "Times New Roman" (font-family-list))
                                                (set-fontset-font "fontset-default" 'unicode "Times New Roman"))

                                              (when (member "Unifont" (font-family-list))
                                                (set-fontset-font t nil "Unifont" nil 'append)
                                                (set-fontset-font t nil "Unifont Upper" nil 'append)))
         (string-equal window-system 'x) (progn
                                            (when (member "Noto Color Emoji" (font-family-list))
                                              (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend)
                                              (set-fontset-font "fontset-default" '(#xFE00 . #xFE0F) "Noto Color Emoji"))

                                            (when (member "Unifont" (font-family-list))
                                              (set-fontset-font t nil "Unifont" nil 'append)
                                              (set-fontset-font t nil "Unifont Upper" nil 'append)))))

#+END_SRC

#+RESULTS:

** Ligatures
It has been noted that there is a such thing known as `ligature.el`, which is a preferred solution to this.
#+BEGIN_SRC emacs-lisp

  (require 'fira-code-mode)

  (unless (member "Fira Code Symbol" (font-family-list))
    (fira-code-mode-install-fonts))

  (fira-code-mode-set-font)
  (setq fira-code-mode-disabled-ligatures '("*" "?=" "[]" "x"))
  (add-hook 'prog-mode-hook 'fira-code-mode)

#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode | rainbow-mode | fira-code-mode | hl-line-mode |


* Themes
I might add more themes in the future, but who knows.
** Crypt Theme
A theme I made myself!
#+BEGIN_SRC emacs-lisp

  (load-theme 'crypt t)  ; Loads my theme

#+END_SRC

#+RESULTS:
: t



* Appearances
** All The Icons
#+BEGIN_SRC emacs-lisp

  (require 'all-the-icons)

#+END_SRC

#+RESULTS:
: all-the-icons

** Rainbow Mode
Sometimes, over-zealous, but the peppier the better, am I right?
#+BEGIN_SRC emacs-lisp

  (add-hook 'prog-mode-hook 'rainbow-mode)     ; Enables rainbow mode (colors the background of colors, e.g. #FFFFFF) for programming modes

#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode | rainbow-mode | fira-code-mode | hl-line-mode |

** Highlight Delimiters
Prettier except not.
#+BEGIN_SRC emacs-lisp

  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)  ; Enables Rainbow Delimiters for Programming Languages

#+END_SRC

#+RESULTS:
| rainbow-delimiters-mode | rainbow-mode | fira-code-mode | hl-line-mode |


* Dashboard
** Dashboard ported from Doom
I haven't finished fully setting this up, but I'll do it later.
_SRC emacs-lisp :tangle no
  (require 'dashboard)

  (defface dashboard-banner-logo-title
    '((t :foreground "#EEECEC"
         :weight 'bold
         :height 300))
    "Face for the Dashboard Title")


  (dashboard-setup-startup-hook)
  (setq dashboard-banner-logo-title (propertize "⦓Philosopher's Compendium of the Universe⦔" 'face crypt-dashboard-title))
  (setq dashboard-startup-banner "~/.emacs.d/starfish.png")
  (add-hook 'dashboard-mode-hook (lambda () (setq show-trailing-whitespace nil)))
  (setq dashboard-center-content t
    dashboard-set-heading-icons t
    dashboard-set-file-icons t
    dashboard-set-navigator t)
#+END_SRC



* Modeline
** Truncate String Utils
#+BEGIN_SRC emacs-lisp :results silent
  (defun 2e/mode-line-truncate-string-p (str)
    "returns non-nil if the string should be truncated"
    (or (< (window-total-width) split-width-threshold)
         (and (> (length str) mode-line-truncate-length)
         (not (one-window-p :no-minibuffer)))))

  (defvar-local mode-line-truncate-length 15)                          ; How long should a string at least be until being truncated

  (defun 2e/mode-line-truncate-string (str)                        ; Truncates the string function
    "Returns the truncated string, else return the original string."
    (if (2e/mode-line-truncate-string-p str)                              ; If the string should be truncated
        (concat (substring str 0 mode-line-truncate-length) "...")     ; Add the first 9 characters of the string and append a '...' at the end.
      str))                                                            ; Else, return original string
#+END_SRC

** Modeline Blank Spaces Helper Functions
#+BEGIN_SRC emacs-lisp
  (defun 2e/mode-line-right-align-rest-width ()
    "Returns the length to be conserved at the right side of the modeline."
    (1+ (length display-time-string)))

  (defun 2e/mode-line-right-align ()
    "Returns empty space using the default 'mode-line' face and leaving RESERVE space on the right."
    (propertize " "
            'display `(space . (:align-to (- (+ right right-fringe right-margin)  ,(2e/mode-line-right-align-rest-width)))))) ; This adds up all of the space at the right of the modeline, and subtracts the space we want to conserve

  (defun 2e/static-blank ()
    "Returns a string of one space."
    " ")
#+END_SRC

#+RESULTS:
: 2e/static-blank

** Modeline Save/d Icon
#+BEGIN_SRC emacs-lisp
  (defun 2e/mode-line-modified ()
    "This returns a all-the-icons icon based on the modified state of the buffer."
    (let* (
           (config-alist                                                             ; Lets `config-alist` to be a list of information that we pull from
          '(("*" all-the-icons-faicon "chain-broken" :height 1.2 :v-adjust -0.0)     ; If it's `*`, then call `all-the-icons-faicon` on "chain-broken :height 1.2 :v-adjust -0.0"
            ("-" all-the-icons-faicon "link" :height 1.2 :v-adjust -0.0)             ; If it's `-`, then call `all-the-icons-faicon` on "link :height 1.2 :v-adjust -0.0"
            ("%" all-the-icons-faicon "lock" :height 1.2 :v-adjust 0.1)))            ; If it's `%`, then call `all-the-icons-faicon` on "lock :height 1.2 :v-adjust 0.1"
         (result (cdr (assoc (format-mode-line "%*") config-alist))))                ; Since it's `let*`, the variables are bound sequentially and so `result` can use `config-alist`.
        (propertize (format "%s" (apply (car result) (cdr result)))                  ; We return a propertized string
            'face `(:family ,(all-the-icons-faicon-family))                          ; The family of the font is the string returned from the function `all-the-icons-faicon-family`
            'help-echo (if (string-equal (cadr result) "chain-broken")               ; We add a minibuffer display when we hover over the icon.
                   (format "Buffer: `%s` is modified." (buffer-name))
                     (if (string-equal (cadr result) "link")
                     (format "Buffer: `%s` is saved." (buffer-name))
                     (format "Buffer: `%s` is read-only." (buffer-name)))))))
#+END_SRC

#+RESULTS:
: 2e/mode-line-modified

** Modeline Buffer/Region Information
#+BEGIN_SRC emacs-lisp
  (defun 2e/mode-line-region-info ()
    "Returns a string containing information from the current region, if there is any. The left number is the lines in the region, and the right number is the characters in the region."
    (when mark-active                                                ; When the mark is active (there's actually a highlighted region)
    (let ((lines (count-lines (region-beginning) (region-end)))      ; Set `lines` to be the amount of lines in the region
          (chars (- (region-end) (region-beginning))))               ; Sets `chars` to be the characters in the region
      (concat                                                        ; Adds the pencil octicon to the information
       (propertize (format "%s " (all-the-icons-octicon "pencil"))
                   'face `(:family ,(all-the-icons-octicon-family))
           'display `(raise -0.0))
       (propertize (format "%s:%s" lines chars)
                   'face `(:height 0.9))))))

  (defun 2e/mode-line-region-buffer-info ()
    "Returns either the output of `2e/mode-line-region-info`, or if there isn't a region marked, then return a string containing information from the entire buffer, with the left number being the lines in the buffer, and the right number being the characters in the buffer."
    (if mark-active
      (2e/mode-line-region-info)
    (concat
     (propertize
      (format "%s" (all-the-icons-octicon "pencil"))
      'face `(:family ,(all-the-icons-octicon-family))
      'display `(raise -0.0))
     (propertize
      (concat
       (format "%s:" (car (buffer-line-statistics)))
       "%i")
      'face `(:height 0.9)))))
#+END_SRC

#+RESULTS:
: 2e/mode-line-region-buffer-info

** Modeline Buffer Name, Mode, and VC Branch
#+BEGIN_SRC emacs-lisp :results silent

  (defun 2e/mode-line-buffer-name ()
    (2e/mode-line-truncate-string
     (format "%s"
             (propertize (2e/mode-line-truncate-string
                          (buffer-name))
                         'help-echo (format "Buffer Name: `%s`" (buffer-name))
                         'face `(:foreground "#dfffee")))))

  (defun 2e/mode-line-mode-icon ()
    "Returns the mode icon of the buffer."
    (propertize
     (format "%s" (all-the-icons-icon-for-mode major-mode :v-adjust 0.0))
     'help-echo (format "Major Mode: `%s`" major-mode)
     'face `(:height 170 :family ,(all-the-icons-icon-family-for-buffer))))

  (defun 2e/mode-line-github-vc ()
    (if vc-mode
        (let ((branch (cdr (string-split vc-mode "[:-]"))))
          (concat
           (propertize
            (format "%s " (all-the-icons-octicon "git-branch"))
            'face `(:family ,(all-the-icons-octicon-family) :height 1.3)
            'display `(raise -0.1))
           (propertize (2e/mode-line-truncate-string
                        (format "%s" branch))
                       'face `(:height 0.9))))
      (concat
       (propertize
        (format "%s " (all-the-icons-octicon "git-branch"))
        'face `(:family ,(all-the-icons-octicon-family) :height 1.3)
        'display `(raise -0.1))
       (propertize (format "%s" "(git init)") 'face `(:height 0.9)))))

  (defun 2e/mode-line-mode-vc-info ()
    (if vc-mode
        (let ((branch (cdr (string-split vc-mode "[:-]"))))
          (concat
           "("
           (2e/mode-line-mode-icon)
           ", "
           (propertize (2e/mode-line-truncate-string
                        (format "#%s" branch))
                       'face `(:height 0.9))
           ")"))
      (2e/mode-line-mode-icon)))


  (require 'org-timer)
  (defun 2e/mode-line-org-timer ()
    (unless (eq (org-timer-value-string) "0:00:00 ")
      (propertize (format "Timer: %s" (org-timer-value-string)) 'face `(:weight bold))))

#+END_SRC
** Modeline DateTime
#+BEGIN_SRC emacs-lisp
  (setq display-time-interval 1)                         ; Updates the time every second
  (setq-default display-time-default-load-average nil)   ; Stops the time from displaying the load average
  (display-time)                                         ; Starts displaying the time

  (defun 2e/mode-line-time ()
    "returns the time with the associated clock icon with it."
    (let* ((hour (string-to-number (format-time-string "%I")))
           (icon (all-the-icons-wicon (format "time-%s" hour) :height 1.3 :v-adjust 0.0)))
      (concat
       (propertize (format-time-string " [%d/%a] %k:%M:%S (%z) ") 'face `(:height 0.9))
       (propertize (format "%s " icon) 'face `(:height 1.0 :family ,(all-the-icons-wicon-family)) 'display '(raise -0.0)))))

#+END_SRC

#+RESULTS:
: 2e/mode-line-time

** Modeline Format
#+BEGIN_SRC emacs-lisp :results silent

  (setq-default mode-line-format
                '("%e"
                  (:eval (2e/mode-line-modified))
                  " "
                  (:eval (2e/mode-line-buffer-name))
                  " "
                  (:eval (2e/mode-line-mode-vc-info))
                  " | "
                  (:eval (2e/mode-line-region-buffer-info))
                  " | "
                  (:eval (2e/mode-line-org-timer))
                  (:eval (2e/mode-line-right-align))
                  (:eval (2e/mode-line-time))
                  ))

  (setq-default header-line-format nil)

#+END_SRC

#+RESULTS:


* Keyboard Layout
I'm using `meow` to create my keyboard layout, because I don't feel like writing tons of emacs lisp right now. This might change in the future, if I ever feel like I need more.
** Setup
#+BEGIN_SRC emacs-lisp

  (require 'meow)

  (meow-global-mode 1)

#+END_SRC

#+RESULTS:
: t

** Key Definitions
*** What I Would Like to See
I would like to see an editing system based on:
 - Workman principles
 - I've been thinking about the most optimal editing system, and realized that all of editing basically consists of:
   - Widening or focusing through "containers"
     - Containers include functions, lists, the characters in a symbol, a class, an ordered list, sexps, you name it
   - After focusing on the information that you want to change, you can some things with that data
     - You can view the data, a.k.a. run the data as code through a repl, pull it to a new buffer for viewing, and generally just run operations on the data that won't change it
     - You can mutate the data in several ways
       - You can mutate the data to nil, or basically just deleting the data
       - You can change the data from the beginning or from the end; appending / prepending things
       - You can replace the data with something
         - like a snippet, or just text you've entered
 - Keyboard macros are a great thing; they shrink complexity down, and make it easy to apply the same ideas on different things.
   - It should have something kind of like Beamer, where you can multicursor kmacros.
I've dubbed this new editing system: event-horizon
*** Event Horizon Planning
_SRC emacs-lisp :tangle no
  (define-minor-mode event-horizon-mode)
#+END_SRC

*** Meow Substitute for Event Horizon
I feel like the REALLY important commands for me are:
 - Basic movement, word movement ehh
 - Kill thing would be amazing
 - Avy integration would be mwahh
 - So would some other stuff
#+BEGIN_SRC emacs-lisp

  (meow-define-keys
      ;; state
      'normal
    ;; Movement Related Bindings
    '("w" . meow-prev)
    '("s" . meow-next)
    '("a" . meow-left)
    '("d" . meow-right)
    '("z" . backward-word)
    '("x" . forward-word)
    '("q" . beginning-of-line)
    '("e" . end-of-line)
    '("c" . avy-goto-char)
    ;; Selection / Editing Related Bindings
    '("i" . meow-bounds-of-thing)
    '("u" . "C-u - M-d")
    '("j" . meow-kill)
    '("y" . kill-word)
    '("p" . keyboard-quit)
    '("m" . hydra-windows/body)
    '("o" . meow-insert)
    '("k" . consult-buffer)
    '("l" . consult-line)
    '(";" . hydra-clipboard/body)
    '("]" . set-mark-command))


#+END_SRC

#+RESULTS:

** Meow Thing Remapping
#+BEGIN_SRC emacs-lisp
  (setq meow-char-thing-table
        (list (append (string-to-list "i") 'round)
              (append (string-to-list "o") 'square)
              (append (string-to-list "u") 'curly)
              (append (string-to-list "w") 'string)
              (append (string-to-list "q") 'symbol)
              (append (string-to-list "~") 'window)
              (append (string-to-list "s") 'buffer)
              (append (string-to-list "a") 'paragraph)
              (append (string-to-list "d") 'line)
              (append (string-to-list "e") 'visual-line)
              (append (string-to-list "f") 'defun)
              (append (string-to-list "k") 'sentence)))
#+END_SRC

#+RESULTS:
: ((105 . round) (111 . square) (117 . curly) (119 . string) (113 . symbol) (126 . window) (115 . buffer) (97 . paragraph) (100 . line) (101 . visual-line) (102 . defun) (107 . sentence))


* PDF Viewing
This is kind of at Emacs' frontier, as it leaves the realm of text and moves to graphical images.
** DocView
#+BEGIN_SRC emacs-lisp

  (setq doc-view-scale-internally t
        doc-view-resolution 600)

#+END_SRC

#+RESULTS:
: 600

** PDF-tools
#+begin_src emacs-lisp

  (require 'pdf-tools)
  (pdf-tools-install)

#+end_src

#+RESULTS:


* Youtube-DL function
I wrote a youtube-dl function which works alright.
#+begin_src emacs-lisp :results silent

  (defun youtube-dl (link)
    "Interactively downloads a youtube video as music."
    (interactive "MYoutube Link: ")
    (async-shell-command (format "youtube-dl --extract-audio --output=\"C:/Users/linyi/OneDrive/Documents/Music/%%(title)s-%%(id)s.%%(ext)s\" --restrict-filenames --audio-format=\"mp3\" %s" link)))

#+end_src

#+RESULTS:
: youtube-dl


* Org Mode
This is honestly one of the main reasons I use Emacs.
** Built-In
This mainly tweaks some org-mode defaults.
#+BEGIN_SRC emacs-lisp

  (setq org-ellipsis nil)
  (setq org-startup-folded t)
  (add-hook 'org-mode-hook 'visual-line-mode)
  (setq org-startup-indented t)

  (setq org-modules '(org-bibtex
                      org-habit
                      org-info
                      org-bbdb
                      org-inlinetask
                      org-mew))

#+END_SRC

#+RESULTS:
| org-bibtex | org-habit | org-info | org-bbdb | org-inlinetask | org-mew |

** Org Edit Latex
#+begin_src emacs-lisp

  (require 'org-edit-latex)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (latex . t)))

  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)

#+end_src

#+RESULTS:

** Org Bullets
#+BEGIN_SRC emacs-lisp

  (require 'org-bullets)
  (setq org-hide-leading-stars t)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  (setq org-bullets-bullet-list '("⁖"))

#+END_SRC

#+RESULTS:
| ⁖  |

** Org TODO
#+BEGIN_SRC emacs-lisp

  (setq org-todo-keywords
        '((sequence "TODO(t)" "WORKING(w)" "SUBMIT(s)" "|" "DONE(d)" "PUSHED(p)" "RAISED(r)" "CANCELED(c)")))
                                          ; TODO: Tasks I haven't started yet and will do in the near near future
                                          ; WORKING: Tasks I'm currently working on -- this shouldn't exceed 3.
                                          ; SUBMIT: Tasks that I've finished, and am waiting to submit it
                                          ; DONE: Tasks that I don't have to ever think about again
                                          ; PUSHED: Tasks in old task lists that has been pushed to future task lists
                                          ; RAISED: Tasks in old task lists that has been raised up a level
                                          ; CANCELED: Tasks that has been canceled

#+END_SRC

#+RESULTS:
| sequence | TODO(t) | WORKING(w) | SUBMIT(s) |   |   | DONE(d) | PUSHED(p) | RAISED(r) | CANCELED(c) |

** Org Agenda and Task List Creation
#+BEGIN_SRC emacs-lisp :tangle no
  ;; (setq org-default-notes-file (concat "C:/Users/linyi/OneDrive/Documents/School/default.org"))

  ;; (setq org-capture-templates
  ;;       '(("f" "Future Task" entry (file (2e/find-create-task-list "F")))
  ;;         ("q" "Quick Task" entry (file (2e/find-create-task-list "Q")))))

  ;; (defvar 2e/current-task-list
  ;;   nil
  ;;   "Holds the current task list.")

  ;; (defun 2e/parse-task-list-date (full-path)
  ;;   "Takes in an ABSOLUTE file path and parses it into a time. This is intended for usage for my task list structure."
  ;;   (let* ((filename (car (last (split-string full-path (rx "/")))))
  ;;          (date-part (split-string filename (rx ".")))
  ;;          (date-list (split-string (car date-part) "-")))
  ;;     (date-to-time (format "%s, %s %s %s"
  ;;                           (caddr date-list)
  ;;                           (cadr date-list)
  ;;                           (car date-list)
  ;;                           (cadr (split-string (car (last (butlast (split-string
  ;;                                                                    (file-name-parent-directory (file-name-parent-directory full-path))
  ;;                                                                    (rx "/")))))))))))

  ;; (defun 2e/incremental-search-through (list-of-stuff search-for)
  ;;   "goes through ")


  ;; ;; (defun 2e/find-current-task-list ()
  ;; ;;   )

  ;; (defun 2e/create-new-task-list ()
  ;;   (let* ((task-list-dir (concat
  ;;                          "C:/Users/linyi/OneDrive/Documents/School/Planner/"
  ;;                          (format-time-string "%B %Y")
  ;;                          "/Task Pages/"))
  ;;          (task-list-file (concat
  ;;                           task-list-dir
  ;;                           "/"
  ;;                           (format-time-string "%B-%d-%a.org"))))
  ;;     (condition-case nil (make-directory task-list-dir)
  ;;       (error nil))
  ;;     (with-temp-buffer (write-file task-list-file))
  ;;     (setq 2e/current-task-list task-list-file)))

  ;; (defun 2e/check-task-list ()
  ;;   "Returns t if you need to make a new task list, else nil. If there's more than 23 todos in the list, it'll return t."
  ;;   (if (>= (length (org-map-entries t "LEVEL=1" '(list 2e/current-task-list))) 24)
  ;;       (length (org-map-entries t "LEVEL=1" '(list 2e/current-task-list)))
  ;;     nil))

  ;; (setq org-agenda-files (if (2e/check-task-list)
  ;;                            (2eo/create-new-task-list)
  ;;                          2e/current-task-list))

#+END_SRC

#+RESULTS:

** Citation management
Citation management in org mode is great but for fuck's sake is hard to figure out.
*** Citation Exports
#+begin_src emacs-lisp
  (setq org-cite-export-processors
        '((md . (csl "chicago-fullnote-bibliography.csl"))
          (latex biblatex)
          (odt . (csl "chicago-fullnote-bibliography.csl"))
          (t . (csl "modern-language-association.csl"))))
#+end_src

#+RESULTS:
| md    | csl      | chicago-fullnote-bibliography.csl |
| latex | biblatex |                                   |
| odt   | csl      | chicago-fullnote-bibliography.csl |
| t     | csl      | modern-language-association.csl   |

*** Zotra
#+begin_src emacs-lisp
  (require 'zotra)
#+end_src

#+RESULTS:
: zotra


* Vertico
Vertico is a completion system that is (1) fully compatible with Emacs' default completion system and (2) displays the data in a vertical manner, allowing you to view it easier. I use Vertico with Posframe, because I think it looks better.
** Setup
#+BEGIN_SRC emacs-lisp

  (require 'vertico-posframe)
  (vertico-posframe-mode 1)
  (vertico-mode 1)
  (vertico-reverse-mode 1)
  (vertico-mouse-mode 1)
  (vertico-indexed-mode 1)
  (setq vertico-count 15)
  (setq vertico-resize 'grow-only)
  (setq vertico-cycle t)
  (global-set-key (kbd "M-SPC") 'vertico-exit-input)

#+END_SRC

#+RESULTS:
: vertico-exit-input


* Misc.
This is where I put all of the miscellaneous things.
** Persistent Scratch
This saves my scratch buffer along multiple sessions.
#+BEGIN_SRC emacs-lisp
  (persistent-scratch-setup-default)
  (setq persistent-scratch-backup-directory "~/scratch-backups/")
#+END_SRC

#+RESULTS:
: ~/scratch-backups/

** Spacious Padding
This pads the space in between buffer frames.
#+BEGIN_SRC emacs-lisp

  (setq spacious-padding-widths '(:internal-border-width 0 :right-divider-width 1 :scroll-bar-width 0))
  (spacious-padding-mode)

#+END_SRC

#+RESULTS:
: t

** Keyfreq
Keyfreq stores keys pressed, allowing you to obtain statistics on what commands you use the most.
#+BEGIN_SRC emacs-lisp
  (require 'keyfreq)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
#+END_SRC

#+RESULTS:
: t

** Indent-Guides
#+begin_src emacs-lisp

  (indent-guide-global-mode t)
  (add-hook 'org-mode-hook (lambda () (indent-guide-mode -1)))

#+end_src

#+RESULTS:
| (lambda nil (indent-guide-mode -1)) | (lambda nil (org-bullets-mode 1)) | visual-line-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

** Olivetti
#+begin_src emacs-lisp

  (require 'olivetti)
  (2e/add-function-to-multiple-hooks 'olivetti-mode '(text-mode-hook
                                                   prog-mode-hook
                                                   Info-mode-hook
                                                   pdf-view-mode-hook
                                                   org-mode-hook))
#+end_src

#+RESULTS:
| text-mode-hook | prog-mode-hook | Info-mode-hook | pdf-view-mode-hook | org-mode-hook |

** Transparency
#+begin_src emacs-lisp
  (set-frame-parameter nil 'alpha-background 70)
  (add-to-list 'default-frame-alist '(alpha-background . 70))

  (defun toggle-transparency ()
    (interactive)
    (let ((alpha (frame-parameter nil 'alpha)))
      (set-frame-parameter
       nil 'alpha
       (if (eql (cond ((numberp alpha) alpha)
                      ((numberp (cdr alpha)) (cdr alpha))
                      ;; Also handle undocumented (<active> <inactive>) form.
                      ((numberp (cadr alpha)) (cadr alpha)))
                100)
           '(85 . 50)
         '(100 . 100)))))

  (global-set-key (kbd "C-c t") 'toggle-transparency)
#+end_src

#+RESULTS:
: toggle-transparency

** Marginalia
Marginalia adds metadata to completion systems. I have to make a new level 1 node for completion frameworks in general and move this there.
#+BEGIN_SRC emacs-lisp

  (require 'marginalia)
  (marginalia-mode 1)
  (setq marginalia-max-relative-age 0)
  (setq marginalia-align 'right)
  (all-the-icons-completion-mode)
  (add-hook 'marginalia-mode 'all-the-icons-completion-marginalia-setup)

#+END_SRC

#+RESULTS:
| all-the-icons-completion-marginalia-setup | t |

** Random stuff
#+begin_src emacs-lisp

  (defun sudden-kill-line ()
    (interactive)
    (move-beginning-of-line nil)
    (kill-line)
    (kill-line)
    (previous-line)
    (end-of-line nil))

  (defun org-fix-latex ()
    (interactive)
    (move-beginning-of-line nil)
    (insert "#+LATEX: "))

  (global-auto-revert-mode t)
  (global-set-key (kbd "C-k") 'sudden-kill-line)
  (global-set-key (kbd "C-c m") 'dabbrev-expand)
  (global-set-key (kbd "C-s") 'consult-line)
  (global-set-key (kbd "C-x b") 'consult-buffer)
  (global-set-key (kbd "C-x o") 'ace-window)
  (global-set-key (kbd "C-c i") 'ibuffer)
  (global-set-key (kbd "C-c a") 'embark-act)

  (setq-default embark-prompter 'embark-completing-read-prompter)

  (defun 2e-eye-break ()
    "A recursive function that calls itself every 20 minutes to remind you to take a break."
    (2e-emacs-remind "Take a 20 second break to protect your eyes." "Eye Doctor")
    (run-with-timer 1200 nil '2e-eye-break))

  (setq inferior-lisp-program "sbcl")

#+end_src

#+RESULTS:
: sbcl


* EMMS (Emacs MultiMedia System)
Playing music is hard with text. This package allows Emacs to do the impossible: play music in Emacs.
** Specific Windows mpv Hack
The default players don't work on Windows, so I had to make my own player.
#+BEGIN_SRC emacs-lisp

  (require 'emms)
  (emms-minimalistic)

  (define-emms-simple-player win-mpv '(file)
                             (regexp-opt '(".mp3" ".mp4" ".mkv" ".webm"))
                             "mpv")

#+END_SRC

#+RESULTS:
: emms-player-win-mpv-playable-p

** Setup
#+BEGIN_SRC emacs-lisp
  (emms-minimalistic)
  (setq emms-player-list '(emms-player-win-mpv)
        emms-info-functions '(emms-info-native))
#+END_SRC

#+RESULTS:
| emms-info-native |


* Electric Pair Mode
#+BEGIN_SRC emacs-lisp
  (defun electric-pair-disable-certain-brackets ()                                                           ; Disables some "unwieldy" brackets so ligatures don't get messed up
    (setq-local electric-pair-inhibit-predicate                                                              ; Sets a predicate for inhibiting the adding of a bracket
                '(lambda (c)
                   (or (char-equal c ?<) (char-equal c ?=)))))                                                ; If the character is equal to < or =, inhibit it

    (2e/add-function-to-multiple-hooks 'electric-pair-disable-certain-brackets '(                               ; Adds function to multiple hooks
                                                                              prog-mode-hook                 ;    Adds to all programming modes
                                                                              org-mode-hook                  ;    Adds to Org Mode
                                                                              text-mode-hook                 ;    Adds to Text Mode
                                                                              ))
#+END_SRC

#+RESULTS:
| prog-mode-hook | org-mode-hook | text-mode-hook |


* Avy
** Default Keys Change
#+BEGIN_SRC emacs-lisp

  (require 'avy)
 avy-keys (string-to-list "wasdiop["))

#+END_SRC

#+RESULTS:
| 119 | 97 | 115 | 100 | 105 | 111 | 112 | 91 |


* Hydra
#+BEGIN_SRC emacs-lisp

  (defhydra hydra-windows ()
    "window splitting and hopping"
    ("w" windmove-delete-up)
    ("s" windmove-delete-down)
    ("a" windmove-delete-left)
    ("d" windmove-delete-right)
    ("u" ace-window)
    ("i" delete-other-windows)
    ("o" delete-window)
    ("q" split-window-below)
    ("e" split-window-right)
    ("z" split-root-window-below)
    ("c" split-root-window-right)
    ("h" shrink-window-horizontally)
    ("l" enlarge-window-horizontally)
    ("j" shrink-window)
    ("k" enlarge-window))

  (defhydra hydra-clipboard ()
    "the emacs infinite clipboard"
    ("i" kill-region)
    ("o" kill-ring-save)
    ("p" nil)
    ("d" yank)
    ("w" yank-from-kill-ring))


#+END_SRC

#+RESULTS:
: hydra-clipboard/body



* Orderless
Orderless is a package that extends on general completion, allowing for better and more exact ways to search for things.
#+BEGIN_SRC emacs-lisp

  (require 'orderless)
  (setq completion-styles '(orderless basic))
  (setq completion-category-defaults nil)
  (setq orderless-component-separator ";")


#+END_SRC

#+RESULTS:
: ;



* Alert Toast
Notifications that work in Windows. Windows isn't a good OS for Emacs, but just in case I need to use Emacs on Windows, this is available.
#+BEGIN_SRC emacs-lisp

  (require 'alert-toast)
  (setq alert-default-style 'toast)

#+END_SRC

#+RESULTS:
: toast



* Progressive Overload Pomodoro (Progodoro)
I watched something that talked about how you could slightly increase the pomodoro times every time to train your brain into focusing more and more for longer periods of time, and decided to implement this into Emacs myself.
** Variables
#+BEGIN_SRC emacs-lisp

  (require 'org-timer)

  ;;; Variable Definitions

  (defvar progodoro-countdown nil
    "Stores the current mode of the progodoro. NIL means that the timer has been reset and that the baseline focus time hasn't been recorded yet. 1 means that either the baseline focus time is being recorded now, or has already been recorded. t means that the baseline focus time has already been raised.")

  (defvar progodoro-focus "00:00:00 "
    "The amount of time the progodoro has gone up to as of now. It is stored as a string of format `HH:MM:SS `.")

  (defvar progodoro-recharging-p nil
    "Whether the progodoro is recharging")

  (defvar progodoro-pity 0
    "Every non-long break that a person gets will increase the pity by an integer between 0 and 5. Before every break, it will roll and if the integer between 0 and (100 - pity) is 0, then it will be a long break and pity will be reset.")

#+END_SRC

#+RESULTS:
: progodoro-pity

** Function
#+BEGIN_SRC emacs-lisp
  ;;; Hooks
  (add-hook 'org-timer-done-hook (lambda () (if progodoro-recharging-p
                                                (progn (2e-emacs-remind "Your timer has recharged. You can proceed to discharge the timer again." "Progodoro")
                                                       (setq progodoro-recharging-p nil))
                                              (2e-emacs-remind "Your timer has overloaded. Please recharge your timer." "Progodoro"))))

  ;;; Functions
  (defun 2e/recharge-progodoro ()
    (interactive)
    (let* ((capped-p (>= progodoro-pity 95))
           (roll (random (- 100 (if capped-p 95 progodoro-pity))))
                 (effort (floor (/ (funcall
                                    (lambda (self numbers add) (funcall self numbers add self))
                                    (lambda (numbers add self) (if (null numbers) 0 (+ (* add (car numbers)) (funcall self (cdr numbers) (/ add 60) self))))
                                    (mapcar #'string-to-number (split-string progodoro-focus ":"))
                                    3600) 50)))
                 (pity-increase (random effort)))
           (if (or (= roll 0) (> progodoro-pity 150))
               (progn (setq progodoro-recharging-p t)
                      (org-timer-set-timer (+ 30 (random (if capped-p (+ 70 (- progodoro-pity 95)) 70))))
                      (setq progodoro-pity 0)
                      (message "You are given a long break!"))
             (progn (message (format "Due to your effort of %s, you are given an increase in pity of %s.\nYou rolled a %s." effort pity-increase roll))
                    (setq progodoro-recharging-p t)
                    (setq progodoro-pity (+ pity-increase progodoro-pity))
                    (org-timer-set-timer 5)))))

  (defun 2e/discharge-progodoro ()
    (interactive)
    (cond ((not progodoro-countdown) (progn (org-timer-start)
                                            (setq progodoro-countdown 1)
                                            (message "Starting Forge.")))
          ((eq progodoro-countdown 1) (progn (setq progodoro-focus (org-timer-value-string))
                                             (org-timer-stop)
                                             (message "Progodoro Timer Forged.")
                                             (setq progodoro-countdown t)))
          (t (progn (let ((time-list (split-string progodoro-focus (rx ":"))))

                      (setq progodoro-focus (format "%s:%s:%s "
                                                    (string-to-number (car time-list))
                                                    (+ 5 (string-to-number (cadr time-list)))
                                                    (string-to-number (caddr time-list)))))
                    (org-timer-set-timer progodoro-focus)))))

  (defun 2e/drain-progodoro ()
    (interactive)
    (org-timer-stop)
    (setq progodoro-recharging-p nil)
    (setq progodoro-countdown nil)
    (setq progodoro-focus "00:00:00 "))


    ;;; Keybindings
  (global-set-key (kbd "<home>") '2e/discharge-progodoro)
  (global-set-key (kbd "<end>") '2e/recharge-progodoro)
  (global-set-key (kbd "<f12>") 'org-timer-pause-or-continue)
#+END_SRC

#+RESULTS:
: org-timer-pause-or-continue


* Yasnippet
Yasnippet is great; it made me stop hating LaTeX a bit.
#+begin_src emacs-lisp

  (require 'yasnippet)
  (yas-global-mode 1)

#+end_src

#+RESULTS:
: t



* Flycheck
Only doing this for proselint.
** Setup
#+begin_src emacs-lisp

  (require 'flycheck)
  (global-flycheck-mode)
  (add-hook 'after-init-hook #'global-flycheck-mode)


#+end_src

#+RESULTS:
| global-flycheck-mode | org-persist-load-all | w32-check-shell-configuration | tramp-register-archive-autoload-file-name-handler | magit-maybe-define-global-key-bindings | table--make-cell-map |



* Languages
** Rust
Rust is a great systems language, with strong support for both low-level and high-level. The Rust Foundation though...
#+begin_src emacs-lisp

#+end_src

#+RESULTS:



* Org Roam
#+begin_src emacs-lisp :results silent
  (require 'org-roam)
  (setq org-roam-directory "C:/Users/linyi/OneDrive/Documents/Wiki")
  (org-roam-setup)
  (global-set-key (kbd "C-c n l") 'org-roam-buffer-toggle)
  (global-set-key (kbd "C-c n f") 'org-roam-node-find)
  (global-set-key (kbd "C-c n i") 'org-roam-node-insert)
#+end_src
